# !/bin/bash


# MIT license, explained here:
#   http://www.tldrlegal.com/l/mit

# Copyright (c) 2020 Cefan Daniel Rubin
#
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

# Latest:
#   https://github.com/cdrubin/bash_ui



# internal variables
_stdin=""
_selected_line=1
_chosen=""
_line_count=0
_top=0
_row=0

# shell
_oldIFS=IFS
IFS=$'\n'


# read from stdin and don't block if empty
if [ ! -t 0 ]; then
    read -d '' _stdin
fi


# count number of lines now in _stdin
_line_count=$(($(printf "%s\n" "$_stdin" | wc -l)))
#echo $_line_count


function set_row() {
    exec < /dev/tty
    local _oldstty=$(stty -g)
    stty raw -echo min 0
    echo -en "\033[6n" > /dev/tty
    IFS=';' read -r -d R -a pos
    stty $_oldstty
    _row=$((${pos[0]:2} - 1))
}


function refresh() {
    echo -e "\033[${_top};0H"

    _count=0
    for _line in $_stdin; do
        _count=$((_count+1))
        if [ $_count -eq $_selected_line ]; then
            echo -n -e "\033[7m"; echo -n "$_line"; echo -e "\033[0m"
        else
            echo -n -e "\033[K"; echo $_line
        fi
    done
}



# print out the choices
printf "%s\n" "$_stdin"


# initialize
set_row
_top=$((_row - _line_count))
refresh


_selected_line=1

while read -sn1 key; do

    if [ "$key" == $'\e' ]; then
        read -sn1 -t 1 k1; read -sn1 -t 1 k2;
    elif [ "$key" == "" ]; then
        break
    fi
    key+=${k1}${k2}

    case "$key" in
        $'\e[A'|$'\e0A')  # up arrow
            if [ $_selected_line -gt 1 ]; then ((_selected_line--)); fi; refresh;;

        $'\e[B'|$'\e0B')  # down arrow
            if [ $_selected_line -lt $_line_count ]; then ((_selected_line++)); fi; refresh;;
    esac
done


_count=0
for _line in $_stdin; do
    _count=$((_count+1))
    if [ $_count -eq $_selected_line ]; then
        echo "$_line" > /dev/stderr
    fi
done

IFS=_oldIFS
